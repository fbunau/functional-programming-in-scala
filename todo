/*
This is a todo list of exercises this repo does not have covered / implemented
*/


#### 1 Introduction to functional programming

## 3. Functional data structures

3.12 reverse of a list using fold
3.13 foldLeft using foldRight, and foldRight using foldLeft, making a tail recursive foldRight
3.14 append using either foldLeft or foldRight
3.15 concatenate a list of list into a single list

3.16 transform list of integers by adding 1 to each element
3.17 List[Double] to List[String]
3.18 implement map
3.19 implement filter
3.20 implement flatMap
3.21 use flatmap to implement filter
3.22 function that accepts two lists and constructs a new list by adding the corresponding elements
3.23 generalize to zipWith, so that it's not specific to integers or addition

// example of usage with other List functions defined in the Scala lib

3.24 implement hasSubsequence to check if a list is contained as subsequence in another list

## 4. Handling errors without exceptions

4.2 variance function in terms of flatMap
4.4 function sequence that combines a list of Options into one Option containing
    a list of all the Some values in the original list
4.5 Implement sequence in terms of traverse

4.6 Either versions of map, flatMap, orElse, map2

// example of usage in the InsuranceEngine example with Either to encode the exception

4.7 sequence and traverse for Either
4.8 change map2 implementation so that it can return both errors for InsuranceEngine

## 5. Strictness and laziness

5.4 Implement forAll
5.5 Use foldRight to implement takeWhile
5.6 Hard: Implement headOption using foldRight
5.7 Implement map, filter, append, flatMap, foldRight

5.9 Implement from - integer generation
5.10 Function fibs generating fibonacci numbers
5.11 Implement unfold
5.12 Write fibs, from constant and ones in terms of unfold
5.13 Use unfold to implement map, take, takeWhile, zipWith
5.14 Hard: Implement startsWith using functions youâ€™ve written. It should check if one Stream is a prefix of another.
5.15 Implement tails using unfold. For a given Stream, tails returns the Stream of suffixes of the input sequence, starting with the original Stream.
5.16 Hard: Generalize tails to the function scanRight, which is like a foldRight that returns a stream of the intermediate results

## 6. Purely functional state

6.8 Implement flatMap, and then use it to implement nonNegativeLessThan
6.9 Reimplement map and map2 in terms of flatMap
6.10 Generalize the functions unit, map, map2, flatMap, and sequence and add to State object

6.11 Hard: Implement FSM Candy dispenser